import { GoogleGenAI, Type } from "@google/genai";
import { AnalysisResult, AnalysisData, UserPreferences, GeneratedSite, GeneratedAsset } from "../types";

// Initialize Gemini Client
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

// --- MODEL CONFIGURATION ---
// Model IDs for different purposes
const COMPILER_MODEL = "gemini-2.5-pro-preview-05-06"; // Pro model for deterministic compilation
const FLASH_MODEL = "gemini-2.5-flash"; // Flash for quick operations
const IMAGE_MODEL = "gemini-2.5-flash-preview-native-audio-dialog"; // Image generation model

// --- MASTER SYSTEM PROMPT FOR THE COMPILER ---
const COMPILER_SYSTEM_PROMPT = `You are the **AI Website Design Compiler**, a specialized system acting as a Senior Frontend Engineer and Design Systems Expert.

Your sole function is to deterministically transform structured input data into a single, high-fidelity, production-ready HTML5 file. You do not engage in conversation. You execute a compilation process.

### 1. THE INPUT CONTRACT

You will receive a single JSON object containing three distinct data packets:

\`\`\`json
{
  "sourceData": {
    // The "Old World" - extracted from the original site
    "textContent": {
      "headings": ["Original Headline", "Subheading..."],
      "paragraphs": ["Long boring text..."],
      "ctas": ["Submit"],
      "contactInfo": { "phone": "...", "email": "...", "address": "..." }
    },
    "scrapedImages": {
        "logoUrl": "...",
        "heroUrl": "...",
        "galleryUrls": ["..."]
    }
    // ... other source data
  },
  "userPreferences": {
    // The "New World" definition - from the UI
    "vibe": { "minimal": 0.8, "playful": 0.2 }, // Weighted vector
    "colorPalette": "vibrant-high-contrast", // String identifier
    "typography": "modern-sans-serif", // String identifier
    "layoutFocus": "hero-centric" // String identifier
  },
  "assetUrls": {
    // The "Woah Factor" assets - pre-generated by AI
    "heroImage": "https://...",
    "moodImage": "https://..."
  }
}
\`\`\`

### 2. THE COMPILATION PROCESS

Execute the following steps sequentially to generate the output.

#### Step A: Design Token Synthesis (Tailwind CSS)

Translate abstract \`userPreferences\` into concrete Tailwind utility classes.

- **Color Palette**: Interpret the \`colorPalette\` string:
  - "vibrant-high-contrast" -> high saturation primary/secondary colors, bold contrasts
  - "soft-pastels" -> soft, muted, calming tones
  - "dark-mode-neon" -> dark backgrounds (#0f0f0f), light text, neon accent colors
  - "clean-monochrome" -> grayscale with one accent color

  Define these as CSS variables in a \`<style>\` block, then use Tailwind's arbitrary values (e.g., \`bg-[var(--primary)]\`, \`text-[var(--text-main)]\`).

- **Typography (Dynamic Selection)**: Select the best Google Font pair (Header + Body) by analyzing the intersection of \`userPreferences.typography\` and the dominant \`userPreferences.vibe\`.
  - Analyze Inputs: Determine the primary typography category chosen and identify the vibe with the highest weight.
  - Select Pair:
    - "modern-sans-serif" + "minimal" -> Inter (headers) + Roboto (body)
    - "modern-sans-serif" + "playful" -> Poppins (headers) + Quicksand (body)
    - "modern-sans-serif" + "bold" -> Montserrat (headers, weight 800) + Open Sans (body)
    - "classic-serif" + "elegant" -> Playfair Display (headers) + Lora (body)
    - "classic-serif" + "minimal" -> Cormorant Garamond (headers) + Source Serif Pro (body)
    - "tech-monospace" -> JetBrains Mono (headers) + Fira Code (body)
    - "friendly-rounded" -> Nunito (headers) + Varela Round (body)
  - Implementation: Generate the correct Google Fonts \`<link href="...">\` tag including weights (400, 500, 600, 700) and insert into \`<head>\`.

- **Vibe Dynamics**: Analyze the dominant vibe weights to determine physical properties:
  - **Minimal**: \`rounded-none\` or \`rounded-sm\`, flat/subtle shadows, high whitespace (\`gap-8\`, \`p-12\`), thin borders
  - **Playful**: \`rounded-2xl\` or \`rounded-3xl\`, bouncy shadows (\`shadow-[0_10px_40px_-10px_rgba(0,0,0,0.2)]\`), vibrant gradients
  - **Bold**: Thick borders (\`border-4\`), large text sizes (\`text-5xl+\`), high contrast black/white, uppercase headings
  - **Elegant**: Subtle animations, thin elegant borders, generous letter-spacing, refined spacing

#### Step B: Layout & Structure Strategy

Select a Tailwind layout pattern based on \`layoutFocus\`:

- **hero-centric**: Massive top banner (\`min-h-screen\` or \`h-[80vh]\`), image as background with overlay, oversized H1, centered CTA
- **content-first**: Smaller hero, quick transition to readable text blocks in a central column (\`max-w-prose mx-auto\`)
- **split-screen**: 50/50 vertical division for the landing fold (\`grid grid-cols-2\`), image on one side, text/form on the other
- **visual-grid**: Gallery-style grid layout, Masonry-like feel, multiple images prominently displayed

#### Step C: Content Mapping & Tone Shift (CRITICAL: ANTI-HALLUCINATION)

Populate the layout using \`sourceData.textContent\`.

- **FACTUAL INTEGRITY IS PARAMOUNT.** Do not invent new services, products, testimonials, or facts. Use ONLY the information provided.
- **Tone Rewrite**: Rewrite the headings and paragraphs slightly to match the dominant vibe, but keep the core meaning identical.
  - Minimal -> concise, direct
  - Playful -> friendly, enthusiastic (but no fake claims)
  - Bold -> powerful, confident statements
  - Elegant -> refined, sophisticated language
- **Mandatory Elements**: Ensure the primary CTA button and contact info (phone/email) from the source data are prominently placed.

#### Step D: Asset Integration (Combining Old & New)

You have access to two sets of images:

- \`assetUrls.heroImage\`: A new, high-quality AI-generated hero image.
- \`sourceData.scrapedImages\`: Images from the original website (logo, old hero, gallery).

**Rules for Image Usage:**

1. **Primary Hero**: Use the new \`assetUrls.heroImage\` for the main top banner section.
2. **Logo**: If \`sourceData.scrapedImages.logoUrl\` exists, you MUST use it in the header navigation. Do not replace the brand's logo.
3. **Content Images**: Use \`sourceData.scrapedImages.galleryUrls\` to populate image grids, feature sections, or "About Us" sections.
4. **Styling**: Apply the determined vibe styling (border-radius, shadows) to all images.

### 3. THE OUTPUT CONTRACT

- Output ONLY a single, valid HTML5 code block starting with \`<!DOCTYPE html>\`.
- Must include \`<script src="https://cdn.tailwindcss.com"></script>\` in the \`<head>\`.
- Must include proper Google Fonts links.
- Do not provide any introductory or concluding text. Just the HTML.
- Ensure the final result is fully responsive (mobile-first Tailwind classes: \`sm:\`, \`md:\`, \`lg:\`).
- Include smooth scroll behavior, hover states on buttons/links, and basic accessibility attributes (alt text, semantic HTML).`;

const ANALYSIS_SCHEMA = {
  type: Type.OBJECT,
  properties: {
    businessName: { type: Type.STRING },
    businessType: { type: Type.STRING },
    primaryColor: { type: Type.STRING },
    secondaryColor: { type: Type.STRING },
    accentColor: { type: Type.STRING },
    designIssues: { type: Type.ARRAY, items: { type: Type.STRING } },
    extractedContent: {
      type: Type.OBJECT,
      properties: {
        headline: { type: Type.STRING },
        description: { type: Type.STRING },
        services: { type: Type.ARRAY, items: { type: Type.STRING } },
        contactInfo: { type: Type.STRING }
      }
    },
    recommendedStyle: { type: Type.STRING }
  },
  required: ["businessName", "businessType", "primaryColor", "secondaryColor", "designIssues", "extractedContent", "recommendedStyle"]
};

// --- MOCK DATA (Replace with real backend fetch in production) ---
const MOCK_ANALYSIS_DATA: AnalysisData = {
  scrapeId: 'test-123',
  originalUrl: 'https://bobsplumbing.com',
  textContent: {
    headings: ["Bob's Plumbing Services", "Why Choose Us", "Our Services", "Contact for Quote"],
    paragraphs: [
      "For over 20 years, Bob's Plumbing has provided reliable, affordable service to the metro area. We handle repairs, installations, and emergency calls.",
      "Licensed and insured professionals ready to help 24/7.",
      "From leaky faucets to complete bathroom renovations, we do it all.",
      "Family-owned business with a commitment to quality workmanship."
    ],
    ctas: ['Get a Free Estimate', 'Call Now', 'Schedule Service'],
    contactInfo: {
      phone: '555-0192',
      email: 'bob@bobsplumbing.com',
      address: '123 Main Street, Metro City'
    }
  },
  designTokens: {
    colors: ['#0000FF', '#FFFFFF', '#1a1a1a'],
    fonts: ['Arial', 'Times New Roman']
  },
  scrapedImages: {
    logoUrl: 'https://placehold.co/200x80/1a56db/ffffff?text=Bob%27s+Plumbing',
    heroUrl: 'https://placehold.co/1200x600/1e3a5f/ffffff?text=Professional+Plumbing',
    galleryUrls: [
      'https://placehold.co/400x300/3b82f6/ffffff?text=Service+1',
      'https://placehold.co/400x300/2563eb/ffffff?text=Service+2',
      'https://placehold.co/400x300/1d4ed8/ffffff?text=Service+3'
    ]
  },
  screenshotUrl: 'https://placehold.co/600x400/0f172a/ffffff?text=Old+Site+Screenshot'
};

// --- API FUNCTIONS ---

/**
 * Fetches analysis data for a given URL.
 * In production, this would call your backend API.
 */
export const fetchAnalysisData = async (url: string): Promise<AnalysisData> => {
  console.log(`Fetching analysis for ${url}...`);

  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 1500));

  // In production: return await fetch(`/api/analyze?url=${encodeURIComponent(url)}`).then(r => r.json());
  return {
    ...MOCK_ANALYSIS_DATA,
    originalUrl: url,
    scrapeId: `scrape-${Date.now()}`
  };
};

/**
 * Generates a mood/hero image using the image generation model.
 */
export const generateMoodImage = async (prompt: string): Promise<GeneratedAsset> => {
  console.log(`Generating mood image with prompt: ${prompt}`);

  try {
    const response = await ai.models.generateContent({
      model: IMAGE_MODEL,
      contents: prompt,
      config: {
        responseModalities: ["image", "text"],
      }
    });

    // Extract image from response
    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) {
        return {
          type: 'mood',
          url: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`,
          prompt
        };
      }
    }

    throw new Error("No image data in response");
  } catch (error) {
    console.error("Mood image generation failed:", error);

    // Fallback to placeholder
    const vibeKeyword = prompt.includes('minimal') ? 'minimal' :
                        prompt.includes('bold') ? 'bold' :
                        prompt.includes('playful') ? 'colorful' :
                        prompt.includes('elegant') ? 'luxury' : 'abstract';

    return {
      type: 'mood',
      url: `https://picsum.photos/seed/${vibeKeyword}${Date.now()}/800/600`,
      prompt
    };
  }
};

/**
 * Generates a hero image for the final website.
 */
export const generateHeroImage = async (
  businessContext: string,
  vibe: string
): Promise<GeneratedAsset> => {
  const prompt = `A professional, high-quality photograph for a website hero section.
    Business: ${businessContext}.
    Style: ${vibe}, modern, clean.
    High resolution, cinematic lighting, no text overlays.`;

  console.log(`Generating hero image: ${prompt}`);

  try {
    const response = await ai.models.generateContent({
      model: IMAGE_MODEL,
      contents: prompt,
      config: {
        responseModalities: ["image", "text"],
      }
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) {
        return {
          type: 'hero',
          url: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`,
          prompt
        };
      }
    }

    throw new Error("No image data in response");
  } catch (error) {
    console.error("Hero image generation failed:", error);

    return {
      type: 'hero',
      url: `https://picsum.photos/seed/hero${Date.now()}/1200/800`,
      prompt
    };
  }
};

/**
 * The main compilation function - transforms old site data + preferences into new HTML.
 */
export const compileWebsite = async (
  analysisData: AnalysisData,
  prefs: UserPreferences
): Promise<GeneratedSite> => {
  console.log("Starting website compilation...");

  // 1. Determine dominant vibe
  const vibeKey = Object.keys(prefs.vibe).reduce((a, b) =>
    prefs.vibe[a] > prefs.vibe[b] ? a : b
  );

  // 2. Generate Hero Image
  const businessContext = analysisData.textContent.headings[0] || "a professional business";
  const heroAsset = await generateHeroImage(businessContext, vibeKey);

  // 3. Construct the payload for the compiler
  const payload = {
    sourceData: {
      textContent: analysisData.textContent,
      scrapedImages: analysisData.scrapedImages,
      designTokens: analysisData.designTokens,
      originalUrl: analysisData.originalUrl
    },
    userPreferences: {
      vibe: prefs.vibe,
      colorPalette: prefs.colorPalette,
      typography: prefs.typography,
      layoutFocus: prefs.layoutFocus
    },
    assetUrls: {
      heroImage: heroAsset.url,
      moodImage: prefs.nanoBananaMoodImage || ''
    }
  };

  console.log("Sending payload to compiler model...");

  // 4. Call the Compiler Model with low temperature for deterministic output
  try {
    const response = await ai.models.generateContent({
      model: COMPILER_MODEL,
      contents: [
        { role: 'user', parts: [{ text: JSON.stringify(payload, null, 2) }] }
      ],
      config: {
        systemInstruction: COMPILER_SYSTEM_PROMPT,
        temperature: 0.1,  // CRITICAL: Very low for deterministic output
        topP: 0.8,
        topK: 40,
        maxOutputTokens: 16384, // Ensure enough space for full HTML
      }
    });

    let generatedHtml = response.text || "";

    // Clean up the response - remove markdown code blocks if present
    generatedHtml = generatedHtml
      .replace(/```html\n?/gi, '')
      .replace(/```\n?/gi, '')
      .trim();

    // Validate output
    if (!generatedHtml.includes('<!DOCTYPE html>') && !generatedHtml.includes('<!doctype html>')) {
      console.error("Invalid HTML output:", generatedHtml.substring(0, 500));
      throw new Error("Compiler output was not valid HTML.");
    }

    console.log("Website compilation successful!");

    return {
      html: generatedHtml,
      heroImageUrl: heroAsset.url
    };
  } catch (error) {
    console.error("Compilation failed:", error);
    throw error;
  }
};

/**
 * Refines the generated website based on user feedback.
 */
export const refineWebsite = async (
  currentHtml: string,
  instruction: string,
  analysisData: AnalysisData
): Promise<string> => {
  const prompt = `You are a professional frontend developer. Modify this website based on the user's request.

USER REQUEST: "${instruction}"

IMPORTANT RULES:
1. Only modify what the user asks for
2. Preserve the overall structure and styling
3. Do NOT add fake content or testimonials
4. Keep all original business information (from the original site)
5. Return ONLY the complete, valid HTML - no explanations

BUSINESS CONTEXT (for reference, do not invent new information):
- Business: ${analysisData.textContent.headings[0]}
- Services: ${analysisData.textContent.paragraphs.join(' ')}
- Contact: Phone ${analysisData.textContent.contactInfo.phone}, Email ${analysisData.textContent.contactInfo.email}

CURRENT HTML:
${currentHtml}

Return the modified HTML:`;

  try {
    const response = await ai.models.generateContent({
      model: FLASH_MODEL,
      contents: prompt,
      config: {
        temperature: 0.2,
        maxOutputTokens: 16384,
      }
    });

    let code = response.text || "";
    code = code.replace(/```html\n?/gi, '').replace(/```\n?/gi, '').trim();

    return code;
  } catch (error) {
    console.error("Refinement failed:", error);
    throw error;
  }
};

// --- LEGACY FUNCTIONS (for backward compatibility) ---

/**
 * Analyzes screenshots of a website.
 */
export const analyzeScreenshot = async (base64Images: string[]): Promise<AnalysisResult> => {
  const imageParts = base64Images.map(img => {
    const cleanBase64 = img.split(',')[1] || img;
    return { inlineData: { mimeType: "image/png", data: cleanBase64 } };
  });

  const prompt = `
    Analyze these website screenshots.
    Extract the business details, colors, and content.
    Identify design issues that make it look old or unprofessional.
    Suggest a modern recommended style.
  `;

  try {
    const response = await ai.models.generateContent({
      model: FLASH_MODEL,
      contents: {
        parts: [
          ...imageParts,
          { text: prompt }
        ]
      },
      config: {
        responseMimeType: "application/json",
        responseSchema: ANALYSIS_SCHEMA
      }
    });

    if (response.text) {
      return JSON.parse(response.text) as AnalysisResult;
    }
    throw new Error("No analysis data returned");
  } catch (error) {
    console.error("Analysis failed:", error);
    throw error;
  }
};

/**
 * Analyzes a URL using search grounding.
 */
export const analyzeUrl = async (url: string): Promise<AnalysisResult> => {
  try {
    const searchPrompt = `
      Find information about the business at this URL: ${url}.
      I need to know:
      1. Business Name and Type
      2. What services they offer
      3. Their likely branding colors (if found, otherwise infer from industry)
      4. Typical design issues for this type of business's old websites
    `;

    const searchResponse = await ai.models.generateContent({
      model: FLASH_MODEL,
      contents: searchPrompt,
      config: { tools: [{googleSearch: {}}] }
    });

    const searchData = searchResponse.text;

    const structurePrompt = `
      Based on this research about ${url}:
      ${searchData}

      Create a structured website analysis.
      Assume a "Before" state that needs improvement.
      Fill in the JSON schema.
    `;

    const structuredResponse = await ai.models.generateContent({
      model: FLASH_MODEL,
      contents: structurePrompt,
      config: {
        responseMimeType: "application/json",
        responseSchema: ANALYSIS_SCHEMA
      }
    });

    if (structuredResponse.text) {
      return JSON.parse(structuredResponse.text) as AnalysisResult;
    }
    throw new Error("Failed to structure URL analysis");

  } catch (error) {
    console.error("URL Analysis failed:", error);
    throw error;
  }
};

/**
 * Legacy image generation function.
 */
export const generateAssetImage = async (prompt: string, type: 'hero' | 'feature'): Promise<GeneratedAsset> => {
  try {
    const response = await ai.models.generateContent({
      model: IMAGE_MODEL,
      contents: prompt,
      config: {
        responseModalities: ["image", "text"],
      }
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) {
        return {
          type,
          url: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`,
          prompt
        };
      }
    }
    throw new Error("No image data generated");
  } catch (error) {
    console.error("Image generation failed:", error);
    return {
      type,
      url: `https://picsum.photos/${type === 'hero' ? '1200/800' : '600/400'}?random=${Math.floor(Math.random() * 1000)}`,
      prompt
    };
  }
};

/**
 * Legacy website code generation.
 */
export const generateWebsiteCode = async (
  analysis: AnalysisResult,
  assets: GeneratedAsset[]
): Promise<string> => {
  const heroAsset = assets.find(a => a.type === 'hero');
  const featureAssets = assets.filter(a => a.type === 'feature');

  const prompt = `
    You are an expert frontend engineer. Rebuild this website.

    ANALYSIS:
    Name: ${analysis.businessName}
    Type: ${analysis.businessType}
    Style: ${analysis.recommendedStyle}
    Colors: Primary ${analysis.primaryColor}, Secondary ${analysis.secondaryColor}, Accent ${analysis.accentColor}
    Content:
      Headline: "${analysis.extractedContent.headline}"
      Desc: "${analysis.extractedContent.description}"
      Services: ${analysis.extractedContent.services.join(', ')}
      Contact: "${analysis.extractedContent.contactInfo}"

    ASSETS TO USE:
    Hero Image: "${heroAsset?.url || 'https://via.placeholder.com/1200'}"
    Feature Images:
    ${featureAssets.map((a, i) => `Image ${i+1}: "${a.url}"`).join('\n')}

    REQUIREMENTS:
    1. Single HTML file.
    2. Use Tailwind CSS via CDN.
    3. Modern, clean, responsive design using the recommended style.
    4. Sections: Navbar, Hero, About, Services, Contact, Footer.
    5. Use the specific colors provided.
    6. Return ONLY raw HTML.
  `;

  try {
    const response = await ai.models.generateContent({
      model: FLASH_MODEL,
      contents: prompt,
    });

    let code = response.text || "";
    code = code.replace(/```html/g, "").replace(/```/g, "");
    return code;
  } catch (error) {
    console.error("Code generation failed:", error);
    throw error;
  }
};

/**
 * Legacy refinement function.
 */
export const refineWebsiteCode = async (currentHtml: string, userInstruction: string): Promise<string> => {
  const prompt = `
    You are an expert web developer.

    USER INSTRUCTION: "${userInstruction}"

    CURRENT HTML:
    ${currentHtml}

    TASK:
    1. Modify the Current HTML to satisfy the User Instruction.
    2. Keep the rest of the design intact.
    3. Return ONLY the full, valid, updated HTML string.
  `;

  try {
    const response = await ai.models.generateContent({
      model: FLASH_MODEL,
      contents: prompt,
    });

    let code = response.text || "";
    code = code.replace(/```html/g, "").replace(/```/g, "");
    return code;
  } catch (error) {
    console.error("Refinement failed:", error);
    throw error;
  }
};
